(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{127:function(e,o,n){"use strict";var t,i=(t=n(128))&&t.__esModule?t:{default:t};e.exports=function(e){const o=new i.default(e);return{Expression:o.Expression,FlowTypes:o.FlowTypes,NodeTypes:o.NodeTypes,PathTypes:o.PathTypes,LinguisticFlowDefinition:(e,n,t,i,l,s,a,r,c,d,u)=>o.FlowDefinition(e,i,s,r,u),LinguisticNodeDefinition:(e,n,t,i)=>o.NodeDefinition(e,{},i),LinguisticActionsPlural:(e,o,n)=>{},LinguisticActionsSingular:e=>{},LinguisticActions:e=>{},NonemptyListOf:o.NonemptyListOf,LinguisticPath:o.Path,LinguisticPathSeparator:(e,o)=>o.eval(),Import:(e,n,t,i,l)=>o.Import(t,l),LinguisticNodes:o.Nodes,LinguisticMilestone:o.Milestone,LinguisticNode:o.Node,LinguisticWaitsFor:(e,n,t)=>o.WaitsFor(e,t),LinguisticNodeBase:o.NodeBase,LinguisticSilentNode:(e,n)=>o.SilentNode(n),LinguisticIdentityNode:(e,n,t,i)=>o.IdentityNode(e,t),LinguisticStandardNode:o.StandardNode,Concept:o.Concept,LinguisticChannel:o.Channel,LinguisticErrorChannel:(e,n,t,i)=>o.ErrorChannel(n,t),LinguisticPlainChannel:(e,n,t)=>o.PlainChannel(n),LinguisticNamedChannel:(e,n,t,i)=>o.NamedChannel(n,t),Properties:(e,n,t)=>o.Properties(n),Property:(e,n,t)=>o.Property(e,t),HttpMethods:o.HttpMethods,label:o.label,string:(e,n,t)=>o.string(n),_terminal:()=>this.primitiveValue,number:o.number,fraction:o.fraction,whole:o.whole,space:o.space,comment:o.comment,multiLineComment:o.multiLineComment,singleLineComment:o.singleLineComment}}},128:function(e,o,n){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.default=void 0;var t=r(n(33)),i=r(n(36)),l=r(n(34)),s=r(n(35)),a=r(n(12));function r(e){return e&&e.__esModule?e:{default:e}}o.default=class{constructor(e){this.application=e,this.nodeFactories={},this.nodeAliases={}}FlowTypes(e){return console.log("FlowTypes"),e.eval()}NodeTypes(e){return console.log("NodeTypes"),e.eval()}PathTypes(e){return console.log("PathTypes"),e.eval()}Expression(e){return console.log("Expression"),e.eval()}FlowDefinition(e,o,n,t,i){console.log("FlowDefinition");const l=o.eval(),s=n.eval();if(this.application.getFlowByHttp(l,s))throw new Error(`Flow definition already exists for the ${l} ${s} endpoint.`);const r=new a.default(this.application,void 0,e.eval(),t.eval(),void 0,l,s,void 0),c=i.eval();r.connect(c),this.application.registerFlow(r)}NodeDefinition(e,o,n){console.log("NodeDefinition");const t=e.eval();if(this.nodeAliases[t])return this.nodeAliases[t];if(void 0!==this.nodeFactories[t])throw new Error(`Node definition already exists for the ${t}.`);this.nodeFactories[t]=((e,o,n,t)=>new l.default(this.application,void 0,e,void 0,o,t));const i=o.eval();return this.nodeFactories[t](t,[],i,n.eval())}Actions(e){console.log("Actions");const o=e.eval(),n=[];return o.forEach(e=>{if(void 0!==e){const o=this.application.requireAction(e,function(){});n.push(o)}}),n}Path(e,o,n){console.log("Path");const t=e.eval(),i=n.eval(),l=o.eval();let s=l;return i.forEach(e=>{void 0!==e&&(s.connect(e),s=e)}),t.connect(l),t}NonemptyListOf(e,o,n){return console.log("NonemptyListOf"),o.eval()instanceof t.default?[e.eval(),o.eval()].concat(n.eval()):[e.eval()].concat(n.eval())}Import(e,o){return console.log("Import"),{}}Nodes(e){return console.log("Nodes"),e.eval()}LinguisticNodes(e){return console.log("LinguisticNodes"),e.eval()}Milestone(e){return console.log("Milestone"),new s.default(this.application,void 0,`Commit ${e}`,"fcfs",[],[])}LinguisticMilestone(e){return console.log("LinguisticMilestone"),new s.default(this.application,void 0,`Commit ${e}`,"fcfs",[],[])}Node(e){return console.log("Node"),e.eval()}WaitsFor(e,o){console.log("WaitsFor")}NodeBase(e){return console.log("NodeBase"),e.eval()}SilentNode(e){console.log("SilentNode");const o=e.eval();if(this.nodeAliases[o.name])throw new Error("Cannot modify labeled a Path root.");return o}IdentityNode(e,o){console.log("IdentityNode");const n=e.eval(),t=o.eval();if(this.nodeAliases[t])throw new Error(`The ${t} alias already exists.`);return this.nodeAliases[t]=n,n}StandardNode(e){const o=e.eval();return this.nodeAliases[o]?this.nodeAliases[o]:this.nodeFactories[o](o,void 0,void 0,void 0)}Concept(e){console.log("Concept");const o=[];return e.forEach(e=>{void 0!==e&&o.push(e.eval())}),o.join(" ")}Channel(e){return console.log("Channel"),e.eval()}ErrorChannel(e,o){console.log("ErrorChannel");const n=e.eval(),t=o.eval();return new i.default(this.application,void 0,n,void 0,[n],t.retry,[])}PlainChannel(e){console.log("PlainChannel");const o=e.eval();return new t.default(this.application,void 0,"Plain",void 0,[],o.retry,[])}NamedChannel(e,o){console.log("NamedChannel");const n=e.eval(),i=o.eval();return new t.default(this.application,void 0,n,void 0,[n],i.retry,[])}Properties(e){console.log("Properties");const o={};return e.eval().forEach(e=>{void 0!==e&&(o[e[0]]=e[1])}),o}Property(e,o){return console.log("Property"),[e.eval(),o.eval()]}HttpMethods(e){return console.log("HttpMethods"),e.eval()}label(e){return console.log("label"),e.eval().join("")}string(e){return console.log("string"),e.eval()}number(e){return console.log("number"),e.eval()}fraction(e,o,n){console.log("fraction");const t=e.eval(),i="0."+n.eval();return Number(t)+Number(i)}whole(e){return console.log("whole"),Number(e.eval())}space(e){return console.log("space"),e.eval()}comment(e){return console.log("comment"),e.eval()}multiLineComment(e){return console.log("multiLineComment"),e.eval()}singleLineComment(e,o){return console.log("singleLineComment"),o.eval()}}}}]);